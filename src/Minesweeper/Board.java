package Minesweeper;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.swing.JButton;
import javax.swing.JFrame;

import org.w3c.dom.events.MouseEvent;

/**
 * 
 * @author blueajo
 *
 *         This class is a Minesweeper Board
 *
 */
public class Board extends JFrame implements MouseListener {

    private static final long serialVersionUID = 1L;
    private static final int buttonSize = 50;

    private Square[][] grid;
    private int numMines, numMinesFlagged;
    private int numSafe, numSafeRevealed;
    private boolean initialized;

    /**
     * Constructs a square minesweeper board with length and width equal to
     * size, and a numMines number of mines.
     * 
     * @param size
     *            the length and width of the board
     * @param numMines
     *            the number of mines to initialize
     * @throws IllegalArgumentException
     *             if the number of mines is greater than the number of squares
     */
    public Board(int size, int numMines) {

	if (numMines > size * size) {
	    throw new IllegalArgumentException("There cannot be more mines than squares.");
	}

	this.numMines = numMines;
	this.initialized = false;

	this.setTitle("Minesweeper");
	this.setMinimumSize(new Dimension(size * buttonSize, size * buttonSize));
	this.setDefaultCloseOperation(EXIT_ON_CLOSE);

	this.grid = new Square[size][size];

	// Initializes the squares within the array.
	for (int row = 0; row < size; row++) {
	    for (int col = 0; col < size; col++) {
		// Initially, squares are declared not to be mines.
		Square current = new Square(row, col);
		this.grid[row][col] = current;

		this.add(current);
	    }
	}

	this.addMouseListener(this);

	this.setVisible(true);
    }
    
    /**
     * @param e the MouseEvent generated by a click of a square
     */
    public void mouseClicked(MouseEvent e) {
	int clickType = e.getButton();
	
	int xPos = e.getScreenX();
	int yPos = e.getScreenY();
	
	int col = xPos / this.buttonSize;
	int row = yPos / this.buttonSize;
	
	Square sq = this.grid[row][col];
	
	if (clickType == 0) {
	    this.leftClickSquare(sq);
	}
	
	else if (clickType == 2) {
	    this.rightClickSquare(sq);
	}
    }

    
/*    
    *//**
     * 
     * determines an action based on the state of the square clicked... needs to
     * be updated
     * 
     * @param click
     *            the ActionEvent generated by a click of a square
     *//*
    @Override
    public void actionPerformed(ActionEvent click) {
	Square sq = (Square) click.getSource();
	if (!initialized) {
	    initialized = true;
	    firstClick(sq);
	}
	
	
	else if (rightclick) {
	    this.rightClickSquare(sq);
	}
	
	
	else { // leftclick
	    this.leftClickSquare(sq);
	}
    }*/
    

    /**
     * called by actionPerformed when the first square is clicked generates a
     * randomized Minesweeper board
     * 
     * @param clicked
     */
<<<<<<< HEAD
    private void firstClick(Square clicked) { 
        ArrayList<Square> mineOrder = new ArrayList<Square>();
        int size = this.grid.length;
        
        for (int row = 0; row < size; row++) {
            for (int col = 0; col < size; col++) {
            	if(!(clicked.row == row) && !(clicked.col == col)) {
            		mineOrder.add(this.grid[row][col]);
            	}
            }
        }
    	
        // Randomizes the order of the squares to select mines from.
        Collections.shuffle(mineOrder);

        // Sets the first numMines Squares to be mines.
        for (int i = 0; i < numMines; i++) {
            mineOrder.get(i).isMine = true;
        }

        // Sets the number of adjacent mines for each square.
        for (int row = 0; row < size; row++) {
            for (int col = 0; col < size; col++) {
                if (this.grid[row][col].isMine) {
                    ArrayList<Square> adjacent = this
                            .getAdjacent(this.grid[row][col]);

                    for (Square adjSquare : adjacent) {
                        if (!adjSquare.isMine) {
                            adjSquare.numAdjacent++;
                        }
                    }
                }
            }
        }
        
        this.reveal(clicked);
        this.recurseReveal(clicked);
        
        // for testing purposes
        System.out.println(this);
    }
    
    public void recurseReveal(Square clicked) {
    	List<Square> squares = this.getAdjacent(clicked);
    	for(Square square : squares) {
			if(square.isMine) {
				return;
			}
		}
    	recurseRevealHelper(clicked, this.getAdjacent(clicked));
	}
    
    private void recurseRevealHelper(Square clicked, List<Square> adjSquares) {
    	
		for(Square square : adjSquares) {
			this.reveal(square);
			boolean recurseAgain = true;
			List<Square> squares = this.getAdjacent(square);
	    	for(Square squareTwo : squares) {
				if(squareTwo.isMine) {
					recurseAgain = false;
					break;
				}
			}
			if(recurseAgain) {
				recurseRevealHelper(square, squares);
			}
		}
    }

	/**
=======
    private void firstClick(Square clicked) {
	ArrayList<Square> mineOrder = new ArrayList<Square>();
	int size = this.grid.length;

	for (int row = 0; row < size; row++) {
	    for (int col = 0; col < size; col++) {
		mineOrder.add(this.grid[row][col]);
	    }
	}

	// Randomizes the order of the squares to select mines from.
	Collections.shuffle(mineOrder);

	// Sets the first numMines Squares to be mines.
	for (int i = 0; i < numMines; i++) {
	    mineOrder.get(i).isMine = true;
	}

	// Sets the rest of the squares to be safe.
	for (int i = numMines; i < size * size; i++) {
	    mineOrder.get(i).isMine = false;
	}

	// Sets the number of adjacent mines for each square.
	for (int row = 0; row < size; row++) {
	    for (int col = 0; col < size; col++) {
		if (this.grid[row][col].isMine) {
		    List<Square> adjacent = this.getAdjacent(this.grid[row][col]);

		    for (Square adjSquare : adjacent) {
			if (!adjSquare.isMine) {
			    adjSquare.numAdjacent++;
			}
		    }
		}
	    }
	}

	// for testing purposes
	System.out.println(this);
    }

    /**
>>>>>>> origin/master
     * Runs through the process of the user left-clicking on a tile. If the tile
     * is flagged or has already been revealed, nothing occurs.
     * 
     * @param sq
     *            the square the user clicked on
     */
    public void leftClickSquare(Square sq) {
<<<<<<< HEAD
        if (!sq.isFlagged && !sq.isRevealed) {
            // Case when the square is a mine, and the user has lost:
            if (sq.isMine) {
                this.endGame(false);
            }

            // Case when the square is not a mine, and becomes revealed:
            else {
                this.reveal(sq);

                // If the square has no adjacent mines, reveals all adjacent
                // squares.
                if (sq.numAdjacent == 0) {
                    for (Square adjacent : this.getAdjacent(sq)) {
                        this.reveal(adjacent);
                    }
                }
            }
        } else if (sq.isRevealed) {
        	// recursively reveal
        }
=======
	if (!sq.isFlagged && !sq.isRevealed) {
	    // Case when the square is a mine, and the user has lost:
	    if (sq.isMine) {
		this.endGame(false);
	    }

	    // Case when the square is not a mine, and becomes revealed:
	    else {
		this.reveal(sq);

		// If the square has no adjacent mines, reveals all adjacent
		// squares.
		if (sq.numAdjacent == 0) {
		    for (Square adjacent : this.getAdjacent(sq)) {
			this.reveal(adjacent);
		    }
		}
	    }
	}
>>>>>>> origin/master
    }

    /**
     * Flags the square that the user right clicks on. Does nothing if the user
     * right clicks on an already revealed square.
     * 
     * @param sq
     *            the square that the user right clicked
     */
    public void rightClickSquare(Square sq) {
	if (!sq.isRevealed) {
	    
	    if (sq.isFlagged) {
		this.numMinesFlagged--;
	    } else {
		this.numMinesFlagged++;
	    }
	    
	    // Toggle square's flagged status:
	    sq.isFlagged = !sq.isFlagged;
	}
    }

    /**
     * Reveals the given square if it is not flagged and *does graphical stuff*
     * associated with revealing it.
     * 
     * @param sq
     *            the square to reveal
     */
    private void reveal(Square sq) {
	if (!sq.isRevealed) {
	    sq.isRevealed = true;

	    // Do more graphical stuff

	}
    }

    /**
     * Runs the end of the game process. Behavior depends on if the user won.
     * 
     * @param wasGameWon
     *            true if the user won the game, false if the user lost
     */
    private void endGame(boolean wasGameWon) {
	// Do stuff
    }

    /**
     * Currently returns a grid composed of "X" and "O" representing mines and
     * non-mines respectively.
     * 
     * @return a 2D representation of the mine locations, indicated by "X"s
     */
    @Override
    public String toString() {
	String output = "Mine layout:\n";

	for (int row = 0; row < grid.length; row++) {
	    for (int col = 0; col < grid.length; col++) {
		output += grid[row][col].toString();
		output += " ";
	    }
	    output += "\n";
	}

	output += "\nAdjacent mines:\n";

	for (int row = 0; row < grid.length; row++) {
	    for (int col = 0; col < grid.length; col++) {
		output += this.grid[row][col].numAdjacent;
		output += " ";
	    }
	    output += "\n";
	}

	return output;
    }

    /**
     * Returns an ArrayList of squares that are adjacent to the given square.
     * 
     * @param sq
     *            the given square to find adjacent squares of
     * @return an ArrayList of squares that are next to (within a distance of 1)
     *         the square at the given coordinates
     */
    private List<Square> getAdjacent(Square sq) {
	List<Square> adjacent = new ArrayList<Square>();

	for (int i = sq.col - 1; i <= sq.col + 1; i++) {
	    for (int j = sq.row - 1; j <= sq.row + 1; j++) {
		if (!(i == sq.col && j == sq.row) && isInBounds(i, j)) {
		    adjacent.add(this.grid[i][j]);
		}
	    }
	}

	return adjacent;
    }

    /**
     * Determines whether the square at the given coordinates is within the
     * grid's bounds.
     * 
     * @param row
     *            the index of the row
     * @param col
     *            the index of the column
     * @return true if the square is in the grid, false otherwise
     */
    private boolean isInBounds(int row, int col) {
	return (row >= 0) && (row < this.grid.length) && (col >= 0) && (col < this.grid.length);
    }

    /**
     * 
     * @author blueajo
     *
     *         This class is a square on a minesweeper board.
     *
     */
    private static class Square extends JButton {
	private static final long serialVersionUID = 1L;

	public int col, row;

	public boolean isMine;
	public boolean isRevealed;
	public boolean isFlagged;

	public int numAdjacent;

	/**
	 * Constructs a square with coordinates at the given x and y indices.
	 * Initializes the square as not revealed and not flagged. Initializes
	 * size to 10x10 pixels.
	 * 
	 * @param col
	 *            the column of the square
	 * @param row
	 *            the row of the square
	 */
	public Square(int row, int col) {
	    super("blank");
	    this.isRevealed = false;
	    this.isFlagged = false;
	    this.col = col;
	    this.row = row;
	    this.numAdjacent = 0;
	    super.setBounds(this.col * buttonSize, this.row * buttonSize, buttonSize, buttonSize);

	}

	/**
	 * @return "X" if the square is a mine, and "O" if it isn't
	 */
	@Override
	public String toString() {
	    return (isMine) ? "X" : "O";
	}
    }

    @Override
    public void mouseClicked(java.awt.event.MouseEvent e) {
	// TODO Auto-generated method stub
	
    }

    @Override
    public void mouseEntered(java.awt.event.MouseEvent e) {
	// TODO Auto-generated method stub
	
    }

    @Override
    public void mouseExited(java.awt.event.MouseEvent e) {
	// TODO Auto-generated method stub
	
    }

    @Override
    public void mousePressed(java.awt.event.MouseEvent e) {
	// TODO Auto-generated method stub
	
    }

    @Override
    public void mouseReleased(java.awt.event.MouseEvent e) {
	// TODO Auto-generated method stub
	
    }
}
